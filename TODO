stat:
 - ensure bssl is built in release mode when parent project is built in release mode
 - TCP_NODELAY on all connected sockets by default
 - Reduce the number of hostname copies in HttpClientSocketFactory (parsePeerAddr -> hostname, hostname -> hostAddress, hostAddress -> ClientTLSConnection)
 - Create generic socket test base class, use for ClearSocket, ClientTLSSocket, and ServerTLSSocket

tls:
 - revisit HttpClientSocket and HttpServerSocket wantRead and wantWrite:  allow the statemachine to finish the TLS handshake even when the stream is paused.
 - relay current profile (optimization, symbols, asan/tsan) to boringssl cmake build
 - add secure/insecure bit to connected socket log address
 - Integration tests generate root CA, intermediate CAs, trust stores, private keys, and test certs locally if not already there
 - unify socket and ssl error reporting in connected socket interface - map TLS errors onto a few well known error codes, log the rest
 - library initialization, read, write, close, destroy - use password protected private keys
 - client-side validation - verify issuer chain and verify CN and SANs
 - server-side validation - verify issuer chain iff client cert is presented
 - Create integration test that exceeds chain length X client and server
 - Create integration test that presents valid cert for different CN and different SAN
 - Create integration test that presents cert for valid CN/valid SAN that is signed by a non-trusted CA
 - Create integration test that presents expired TTL
 - Create integration test that presents tampered cert
 - Create integration test that presents tampered private key
 - SNI-based server certificate presentation
 - client side session resumption
 - server side session resumption
 - can boringssl lib's memory be reconciled?
 - enable ASLR
 - audit initialization for FIPS
 - Configure and maintain maps of CNs to ServerContexts (for SNI) and CNs to ClientContexts (client map must support one-level wildcard matching).
   Alternatively maintain maps of initialized privatekey+cert+CA tuples and register them with individual SSL contexts when needed.
 - Add support and tests for certificate chains and certificate chain verification
 - add support for mTLS while supporting use of local CA + well-known CA bundle
 - Add test to ensure that client rejects server if server doesn't return a cert
 - Ensure wantRead and wantWrite are set appropriately during handshaking else deadlock

daemon:
 - Base class with preFork and postFork functions.  Subclass can bind to privileged ports in preFork
 - If configured, drop privs after postFork
 - Slurp keystore readable only by root into memory before dropping privs.  Use for private key password
 - start() takes over thread and waits for sigchild... restarting child processes that exit non-zero
 - catch SIGTERM and relay SIGTERM to child pid
 - maintain counters that track restarts
 - crash loop handling - exponential backoff with jitter?

stat:
 - add aborts on error to either proactive client and server functions or to handler
 - pause/resume and possibly abort should always update the multiplexer
 - modify produceRequestBody and produceResponseBody to return bytes actually produced, and incorporate into client and server sockets.

proxy:
 - add a test for origin that sends a connection:close without a content-length and without a transfer-encoding.  Proxy should treat the rest of the stream as the body.
 - for proxy initiated connections, do not blindly relay connection close headers and content-length/transfer encoding headers from the client and server.
 - relay error codes to handler.endTransaction().  Instead of returning true|false in handleRead(), etc, return ESB::Error to the multiplexer and pass these back to the handlers.
 - implement idle check - and make it work with paused sockets? (or not - the other socket in the inbound/outbound pair should timeout and propagate the timeout by calling abort)
 - move HttpServerHandler, HttpClientHandler, HttpMultiplexer and their deps into http-common.  Leave HttpMultiplexerExtended in http1
 - do not wait to receive entire request body before sending response body.  Instead stream them concurrently
 - add protocol coverage/interoperability tests:
   - (no request body/wait for socket close, unencoded request body / content length 0, chunked request body) X (client,server) X (request,response)
   - pipelining client that doesn't wait for the current transaction to complete before sending the next request
   - concurrent request/response streaming
   - correct handling when the server sends a response early... when shoudl it close the connection before finishing the response?
 - add stress tests:
   - proxy: backpressure works for clients that read response body slowly
   - proxy: backpressure works for servers that read request body slowly
   - server: idle timeout for slow loris clients
   - client: idle timeout for slow loris servers - this and above may show that transmit pause/resume is needed with EPOLLET
   - server: mangled http client
   - client: mangled http server
   - proxy/client: servers that listen but never accept connections
   - use netem to simulate lots of tiny reads, packet loss, etc.
   - peers close sockets while pooled/paused or at other random times
 - Reduce proxy handler copying with a swapping rule (from recv to send):  swap iff send is empty and recv has no data from the next transaction in it.  Else copy
 - release send buffer when transitioning to parse headers.  acquire send buffer when transitioning to format headers (and later for bidy body streaming)
 - release recv buffer when transitioning to format headers.  acquire recv buffer whwn transitioning to parse headers (and later for bidi body streaming)

performance and efficiency:
 - do not unconditionally close server sockets after sending an error response - make that configurable and add a test for it
 - modify multiplexer - first write, then read.
 - Consider compacting recvBuffer unconditionally for every ServerSocket and ClientSocket handleReadable event.  This would do more memmoves in exchange for fewer socket recvs.
 - Consider using low watermarks for compacting and filling recvBuffer
 - Server socket:  release send and recv buffers in between transactions unless there's data for the next transaction in the app or socket recv buffs.
 - Consider always registering for read and write events and just discard events we don't care about / avoid a bunch of epollctl MOD calls.
 - Consider filling the recv buffer with data for the next transaction but not processing it until the current transaction completes.
 - compare performance of RELEASE vs RELEASENOPOOL vs. RELEASENOPOOL+tcmalloc on bare metal.  If allocators aren't the best option, limit their use to HttpTransaction and use standard new/delete/new[]/delete[] everywhere else.
 - try https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=70da268b569d32a9fddeea85dc18043de9d89f89

connection pool rework:
 - fix regression caused by switch from rb tree to hash table for connection pool.  https://docs.google.com/spreadsheets/d/1UOR-96YUOYD5poKrTPQv_GthBPWZb_fJzd6D4k0aNIk/edit#gid=2084099544
 - create option of global or per-silo connection pool and set default to per-silo.
 - create a counter for hit rate (averaging counter, add 1 for hit, 0 for miss)
 - enforce max connections per destination address (ip + port + transport + encrypted tuple)
 - evict old connections

code health:
 - Share more code between HttpClientSocket and HttpServerSocket
 - replace all these memcpy's of ESB::Buffer internals with a convenience function
 - Fewer log levels.  just error, warning, info, debug
 - Naming consistency:  pool to factory, create to acquire, destroy to release, handler to callback, getFoo to foo
 - add noexcept and allocator references to all uses of placement new
 - use allocator cleanup handlers in embedded list test and more widely
 - use references instead of pointers when they shouldn't be NULL
 - Split HttpMultiplexer into two interfaces: one for HttpServerSocket (call it HttpServerInternals)  and one for HttpListeningSocket+HttpServerHandler
 - Split HttpClientStack into two interfaces: one for HttpClientSocket (call it HttpClientInternals) and one for HttpClientHandler
 - reduce the number of name() and getName() functions
 - rework context name() composition/hierarchy.  Perhaps use variadic args in TCPConnectedSocket?

router:
 - create async router infra.  How can the async response be relayed?  callback function?
 - server trans routing:  resolve to VIP/hostname.  Use right after HTTP request headers have been received in ESHttpServerSocket.
 - client trans routing:  resolve to destination address.   Use in ESHttpClientSocketFactory::ExecuteClientTransaction()
 - make VIP/hostname first class member of transaction.  only routers can set it.  a naive router could set it to the host:port from the request URI
 - create simple DNS based async router impl.  Threadpool + synchronous DNS system resolver + local TTL and LRU-based cache.

load shedding:
 - pause/resume for http listening sockets (overloaded use case).  support PAUSE returns from HttpServerHandler::acceptConnection
 - each multiplexer allocs array of max fd epoll events.  instead divide max fds by num multiplexers?  woudl ahve to ensure that no more than num max fds will be used in a multiplexer - don't accept new connections unless you have 2 fd free (1 fd for server connection, 1 fd for client connection)

http stack test
 - support many virtual IPs in client server tests so we can exercise more ports.  Current max tested is 25k client -> 25k server.
 - pin threads / fe-be connection alignment / packet steering

server:
 - start as root, bind to ports/call initialize(), drop privs, call start()
 - readiness and liveness check support - e2e vs local options
 - plugin api

allocators:
 - add ctrs for discard allocator to track extra large chunk allocations
 - add counters to track stranded memory in discard allocators
 - create an option to disable all allocators - just forward to the source allocator unless you are system.  Then see if there are memory leaks and measure perf difference.  also measure perf difference vs. tcmalloc
 - Should placement new automatically set cleanup handler if object has one?  Put cleanup handler in ESB::Object?

containers:
 - lockless linked list
 - lockless hash table which uses lockless linked lists

sockets:
 - ipv6 support
 - tls support via boringssl
 - ktls sockmap and splice

cmake:
 - finish todos in config.cmake - a few adhoc test programs
 - doxygen
 - code coverage
 - addr space randomization
 - more *san (undefined behavior detector, etc)

async dns client:
 - cares
 - start with caching sync impl and async interface.  cache according to the dns record ttl and LRU
 - common caching code.  intial async impl can use threadpool and gethostbyname

tcp proxy stuff:
 - make sure full duplex
 - track bps
 - turn into a unit test over loopback/same proc

http stuff
 - functions to hex encode/decode header fields
 - merge duplicate headers
 - add user agent/server agent headers
 - remove sensitive headers while proxying
 - fix double add of Transfer-Encoding: chunked.... strip headers that control connection lifetime during proxying
 - idle timeout
 - max requests per connection option (1 disables keepalives, 0 is unlimited)
 - max header size option
 - max body size option
 - save don't skip trailer
 - slow loris defense - not just idle time, also max transaction latency
 - https support
 - h2 support, move parsing and formatting state from sockets to transactions
 - perfect forward secrecy
 - sni-based cert serving
 - ocsp staples
 - support 100 Continue - server side already supported?  client side - do after connection reuse?
 - support max requests per connection
 - support receiving half closed from client while still sending outstanding response
 - make all the unsigned chars in HttpMessage, HttpRequest, and HttpReponse chars?  UTF-8 only in encoded form?

URL 
 - canonicalization / encode and decode per RFC.  either recursively/fully decode or don't decode multiply encoded sequences.  if decode, must handle utf-8 encoding
 - username and pass.  explicitly drop it.
 - fully but lazily parse query string - if requested parse into a list of key value pairs.

bootstrap config
 - reload when file changes or on SIGHUP.  ports, buffer sizes, etc
 - xds agent could just regenerate this, serializing updates and using atomic moves
 - could potentially break into multiple files for scalability, but then need cross-file atomic update mechanism.
 - journalling approach?  base bootstrap file.  log of incremental updates.   compress incremental updates to avoid filling disk

xds support
 - protobuf stubs

logging
 - rotating file logger - batch into memory buffers and flush occasionally.  double buffer.  fill one while flush other.  if one to be filled is too small, drop messages
 - add trace id extension header, copy across all transactions, and include in log messages

perf counters
 - calc percentiles in latency - https://www.codeproject.com/Articles/25656/Calculating-Percentiles-in-Memory-bound-Applicatio
