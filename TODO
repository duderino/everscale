make all these unsigned chars in HttpMessage, HttpRequest, and HttpReponse chars
perf counters
 - log to logger not FILE *
 - revisit efficency of historical perf counter.  turn into a composite with an interval?  rename time series?
 - simple perf counter and averaging counter should track variance - online/incremental variance algo
 - calc percentiles in latency - https://www.codeproject.com/Articles/25656/Calculating-Percentiles-in-Memory-bound-Applicatio
multiplex socket
 - consider not exposing isRunning to impls... they should be returning asap anyways
 - each multiplexer allocs array of max fd epoll events.  instead divide max fds by num multiplexers
logging
 - rotating file logger - batch into memory buffers and flush occasionally.  double buffer.  fill one while flush other.  if one to be filled is too small, drop messages
http stack test
 - create proxy test:  proxy callbacks + route API
 - support many hostnames in client server tests so we can exercise more ports.  Current max tested is 25k client -> 25k server.
 - make sure failover allocators are sufficiently tested or remove them
 - flakey http1 parser test
 - bind to ephemeral port in stack unit tests
 - why was std::bad_alloc thrown by http client/server test?  verify -fno-exceptions.  check leaks
 - pin threads / fe-be connection alignment
proxy main
 - start as root, bind to ports, drop privs
 - load shedding
 - readiness and liveness check support - e2e vs local options
 - plugin api
build types
 - existence check in embedded list may be excessive even in NDEBUG.  instead just put flag in embedded list base indicating whether it is in a list or not?
multiplexer dispatcher
 - helpful or harmful?  better to allow unbalance and just let each multipler add whatever it accepts?
 - dispatch to multiplexer with silo affinity/be-fe connection alignment?
allocators
 - add ctrs for discard allocator to track extra large chunk allocations
 - add counters to track stranded memory in discard allocators
 - replace all allocators with system allocator and compare with and without libtcmalloc
containers
 - fix multimap or replace with stl
 - lockless datastructures - list.  hashmap.
sockets
 - ipv6 support
 - tls support via boringssl
 - ktls sockmap and splice
cmake
 - finish todos in config.cmake - a few adhoc test programs
 - doxygen
 - code coverage
 - addr space randomization
docs
 - fix license - 3 levels of derivation
async dns client
 - start with caching sync impl and async interface.  cache according to the dns record ttl and LRU
 - common caching code.  intial async impl can use threadpool and gethostbyname
tcp stuff
 - make sure full duplex
 - track bps
 - turn into a unit test over loopback/same proc
http stuff
 - idle timeout
 - max requests per connection option (1 disables keepalives)
 - max header size option
 - max body size option
 - slow loris defense
 - https support
 - h2 support
 - perfect forward secrecy
 - sni-based cert serving
 - tls staples
 - support 100 Continue
 - support max requests per connection
 - support receiving half closed from client while still sending outstanding response
URL 
 - canonicalization / encode and decode per chromium RFC
 - username and pass
 - fully parse query string
bootstrap config
 - reload when file changes or on SIGHUP.  ports, buffer sizes, etc
 - xds agent could just regenerate this, serializing updates and using atomic moves
 - could potentially break into multiple files for scalability, but then need cross-file atomic update mechanism.
 - journalling approach?  base bootstrap file.  log of incremental updates.   compress incremental updates to avoid filling disk
xds support
 - protobuf stubs
