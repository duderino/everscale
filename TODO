socket:
 - only update epoll if fd has changed interest set

connection pool rework:
 - create connection pool class of client sockets to client socket factory.
 - create option of global or per-silo connection pool and set default to better performing option.

code health:
 - Naming consistency:  pool to factory, create to acquire, destroy to release, handler to callback, getFoo to foo
 - add noexcept and allocator references to all uses of placement new
 - use allocator cleanup handlers in embedded list test and more widely
 - use references instead of pointers when they shouldn't be NULL
 - Split HttpServerStack into two interfaces: one for HttpServerSocket (call it HttpServerInternals)  and one for HttpListeningSocket+HttpServerHandler
 - Split HttpClientStack into two interfaces: one for HttpClientSocket (call it HttpClientInternals) and one for HttpClientHandler
 - reduce the number of name() and getName() functions

proxy impl:
 - proxy stack/multiplexer/handler
 - pause/resume for http server sockets
 - pause/resume for http client sockets
 - proxy handler that implements both server and client handlers and uses pause/resume appropriately.  initially copy data from server recv to client send buffers and from client recv to server send buffers.
 - route callback for proxy handler.  given the server trans request headers, pick a destionation address for the client trans.
 - reduce proxy handler copying with a swapping rule (from recv to send):  swap iff send is empty and recv has no data from the next transaction in it.  Else copy

router:
 - create async router infra.  How can the async response be relayed?  callback function?
 - server trans routing:  resolve to VIP/hostname.  Use right after HTTP request headers have been received in ESHttpServerSocket.
 - client trans routing:  resolve to destination address.   Use in ESHttpClientSocketFactory::ExecuteClientTransaction()
 - make VIP/hostname first class member of transaction.  only routers can set it.  a naive router could set it to the host:port from the request URI
 - create simple DNS based async router impl.  Threadpool + synchronous DNS system resolver + local TTL and LRU-based cache.

load shedding:
 - pause/resome for http listening sockets (overloaded use case).  support PAUSE returns from HttpServerHandler::acceptConnection
multiplex socket
 - SO_REUSE_PORT
 - each multiplexer allocs array of max fd epoll events.  instead divide max fds by num multiplexers?  woudl ahve to ensure that no more than num max fds will be used in a multiplexer - don't accept new connections unless you have 2 fd free (1 fd for server connection, 1 fd for client connection)

http stack test
 - support many hostnames in client server tests so we can exercise more ports.  Current max tested is 25k client -> 25k server.
 - pin threads / fe-be connection alignment / packet steering

server:
 - start as root, bind to ports/call initialize(), drop privs, call start()
 - readiness and liveness check support - e2e vs local options
 - plugin api

allocators:
 - add ctrs for discard allocator to track extra large chunk allocations
 - add counters to track stranded memory in discard allocators
 - create an option to disable all allocators - just forward to the source allocator unless you are system.  Then see if there are memory leaks and measure perf difference.  also measure perf difference vs. tcmalloc
 - Should placement new automatically set cleanup handler if object has one?  Put cleanup handler in ESB::Object?

containers:
 - lockless linked list
 - lockless hash table which uses lockless linked lists

sockets:
 - ipv6 support
 - tls support via boringssl
 - ktls sockmap and splice

cmake:
 - finish todos in config.cmake - a few adhoc test programs
 - doxygen
 - code coverage
 - addr space randomization
 - more *san (undefined behavior detector, etc)

docs:
 - fix license - 3 levels of derivation

async dns client:
 - start with caching sync impl and async interface.  cache according to the dns record ttl and LRU
 - common caching code.  intial async impl can use threadpool and gethostbyname

tcp proxy stuff:
 - make sure full duplex
 - track bps
 - turn into a unit test over loopback/same proc

http stuff
 - idle timeout
 - max requests per connection option (1 disables keepalives)
 - max header size option
 - max body size option
 - save don't skip trailer
 - slow loris defense
 - https support
 - h2 support, move parsing and formatting state from sockets to transactions
 - perfect forward secrecy
 - sni-based cert serving
 - ocsp staples
 - support 100 Continue - server side already supported?  client side - do after connection reuse?
 - support max requests per connection
 - support receiving half closed from client while still sending outstanding response
 - make all the unsigned chars in HttpMessage, HttpRequest, and HttpReponse chars?  UTF-8 only in encoded form?

URL 
 - canonicalization / encode and decode per RFC.  either recursively/fully decode or don't decode multiply encoded sequences.  if decode, must handle utf-8 encoding
 - username and pass.  explicitly drop it.
 - fully but lazily parse query string - if requested parse into a list of key value pairs.

bootstrap config
 - reload when file changes or on SIGHUP.  ports, buffer sizes, etc
 - xds agent could just regenerate this, serializing updates and using atomic moves
 - could potentially break into multiple files for scalability, but then need cross-file atomic update mechanism.
 - journalling approach?  base bootstrap file.  log of incremental updates.   compress incremental updates to avoid filling disk
xds support
 - protobuf stubs

logging
 - rotating file logger - batch into memory buffers and flush occasionally.  double buffer.  fill one while flush other.  if one to be filled is too small, drop messages
perf counters
 - calc percentiles in latency - https://www.codeproject.com/Articles/25656/Calculating-Percentiles-in-Memory-bound-Applicatio
