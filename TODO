* replace client stack seed callback with function to exec arbitrary stuff on multiplexer thread.  Use EventSocket and SharedQueue for the impl.
* remove internal locking from EpollMultiplexer
* add global connection pool to client socket factory.  if it doesn't degrade perf keep it
* create an option to disable all allocators - just forward to the source allocator unless you are system.  Then see if there are memory leaks and measure perf difference.  also measure perf difference vs. tcmalloc
* put presentation address+port in all TCP sockets and use in http socket log messages (client, sever, listener)
* http server and client sockets should have 2 io buffers (send and receive).  make sure they can tolerate data from the next transaction
* parse buffers should be stored in the transaction and can be shared by request and response parsers since those too are not concurrently active
* make http server sockets bufferless and transactionless when they are waiting for the next transaction - buffer pools
* Should placement new automatically set cleanup handler... put cleanup handler in ESB::Object
* consider creating page allocator using mmap and using this in ESHttpMultiplexerImpl
* for h2, move parsing and formatting state from sockets to transactions
* add noexcept to all uses of placement new
* use allocator cleanup handlers in embedded list test and more widely
* add log statements to http server+client+listener sockets that pretty print peer/listener address
* pause/resume for http server sockets
* pause/resume for http client sockets
* pause/resome for http listening sockets (overloaded use case)
* proxy handler that implements both server and client handlers and uses pause/resume appropriately.  initially copy data from server recv to client send buffers and from client recv to server send buffers.
* route callback for proxy handler.  given the server trans request headers, pick a destionation address for the client trans.
* reduce proxy handler copying with a swapping rule (from recv to send):  swap iff send is empty and recv has no data from the next transaction in it.  Else copy

multiplex socket
 - SO_REUSE_PORT
 - each multiplexer allocs array of max fd epoll events.  instead divide max fds by num multiplexers?  woudl ahve to ensure that no more than num max fds will be used in a multiplexer - don't accept new connections unless you have 2 fd free (1 fd for server connection, 1 fd for client connection)
http stack test
 - support many hostnames in client server tests so we can exercise more ports.  Current max tested is 25k client -> 25k server.
 - bind to ephemeral port in stack unit tests
 - pin threads / fe-be connection alignment
proxy main
 - start as root, bind to ports/call initialize(), drop privs, call start()
 - load shedding
 - support PAUSE returns from HttpServerHandler::acceptConnection
 - readiness and liveness check support - e2e vs local options
 - plugin api
allocators
 - add ctrs for discard allocator to track extra large chunk allocations
 - add counters to track stranded memory in discard allocators
 - replace all allocators with system allocator and compare with and without libtcmalloc
containers
 - lockless datastructures - linked list and hash table.
sockets
 - ipv6 support
 - tls support via boringssl
 - ktls sockmap and splice
cmake
 - finish todos in config.cmake - a few adhoc test programs
 - doxygen
 - code coverage
 - addr space randomization
 - more *san (undefined behavior detector, etc)
docs
 - fix license - 3 levels of derivation
async dns client
 - start with caching sync impl and async interface.  cache according to the dns record ttl and LRU
 - common caching code.  intial async impl can use threadpool and gethostbyname
tcp stuff
 - make sure full duplex
 - track bps
 - turn into a unit test over loopback/same proc
http stuff
 - idle timeout
 - max requests per connection option (1 disables keepalives)
 - max header size option
 - max body size option
 - save don't skip trailer
 - slow loris defense
 - https support
 - h2 support
 - perfect forward secrecy
 - sni-based cert serving
 - ocsp staples
 - support 100 Continue
 - support max requests per connection
 - support receiving half closed from client while still sending outstanding response
 - make all the unsigned chars in HttpMessage, HttpRequest, and HttpReponse chars?  UTF-8 only in encoded form?
URL 
 - canonicalization / encode and decode per chromium RFC
 - username and pass
 - fully parse query string
bootstrap config
 - reload when file changes or on SIGHUP.  ports, buffer sizes, etc
 - xds agent could just regenerate this, serializing updates and using atomic moves
 - could potentially break into multiple files for scalability, but then need cross-file atomic update mechanism.
 - journalling approach?  base bootstrap file.  log of incremental updates.   compress incremental updates to avoid filling disk
xds support
 - protobuf stubs
logging
 - rotating file logger - batch into memory buffers and flush occasionally.  double buffer.  fill one while flush other.  if one to be filled is too small, drop messages
perf counters
 - calc percentiles in latency - https://www.codeproject.com/Articles/25656/Calculating-Percentiles-in-Memory-bound-Applicatio
