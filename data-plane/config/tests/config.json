{
  "COMMENTS": [
    "TODO create a set of recipes that detail different scenarios - load balancing with failover/load shed, mTLS auth, WAF, DoS, outbound throtting/delay, redirect to HTTPS, etc",
    "AUTH example - valid client cert with matches against specific X509 extensions",
    "Incorp L4 proxying",
    "ip+port should belong to at most 1 range",
    "dependencies must be listed first (topological sort)",
    "warn if OVERLOAD is used",
    "balance types: LEAST_LOADED, RANDOM, ROUND_ROBIN",
    "shed types: SPILLOVER, OVERLOAD, DELAY, REJECT",
    "todo - add request attributes for OVERLOAD, let routing policies act on request attributes",
    "todo play with embedded/inlined representations and have tool topological sort and generate this",
    "IDs must be unique across ranges, clusters, routes, ports, etc",
    "create UUID class with a more compact internal representation, and parse/format capabilities",
    "Must have exactly 1 default client context and 1 default server context",
    "validator should apply different checks if client vs. server vs. proxy"
  ],
  "globals": {
    "io_buffer_size_bytes": 32768,
    "idle_timeout_millis": 30000
  },
  "tls": {
    "contexts": [
      {
        "COMMENT": "Example TLS server context",
        "id": "ec23c29b-605e-4b0b-8bae-a4c4692e6164",
        "materials": {
          "key": {
            "path": "/foo/bar/baz.key"
          },
          "certificate": {
            "path": "/foo/bar/baz.crt"
          },
          "ca": {
            "path": "/foo/bar/ca.crt"
          }
        },
        "options": {
          "COMMENT": "Valid peer_verification values are VERIFY_NONE, VERIFY_ALWAYS, VERIFY_IF_CERT.  VERIFY_IF_CERT can be used to give lesser privileges to anonymous clients",
          "peer_verification": "VERIFY_NONE"
        },
        "add": []
      },
      {
        "COMMENT": "Example TLS client context",
        "id": "518aa91c-1b06-4364-a0bd-850a04563fa9",
        "materials": {
          "ca": {
            "path": "/foo/bar/ca.key"
          }
        },
        "options": {
          "peer_verification": "VERIFY_ALWAYS",
          "certificate_chain_depth": 42
        },
        "add": [
          {
            "on": "HANDSHAKE_FAILURE",
            "mark": {
              "entity": "REQUEST",
              "value": "HANDSHAKE_FAILURE-518aa91c-1b06-4364-a0bd-850a04563fa9"
            }
          }
        ]
      },
      {
        "COMMENT": "Example mTLS client or server context",
        "id": "cdad51ab-9f54-4b9a-bbb5-38568f978019",
        "materials": {
          "key": {
            "path": "/foo/bar/baz.key"
          },
          "certificate": {
            "path": "/foo/bar/baz.crt"
          },
          "ca": {
            "path": "/foo/bar/ca.crt"
          }
        },
        "options": {
          "peer_verification": "VERIFY_ALWAYS",
          "certificate_chain_depth": 42
        },
        "add": []
      }
    ],
    "indices": [
      {
        "COMMENT": "Server TLS context index",
        "id": "81607fb3-7453-4372-995a-5e1f1317fd23",
        "default_context": "ec23c29b-605e-4b0b-8bae-a4c4692e6164",
        "contexts": [
          "cdad51ab-9f54-4b9a-bbb5-38568f978019"
        ]
      },
      {
        "COMMENT": "Client TLS context index",
        "id": "0d50e7dd-2e76-4d3e-b401-2826265893a8",
        "default_context": "518aa91c-1b06-4364-a0bd-850a04563fa9",
        "contexts": [
          "cdad51ab-9f54-4b9a-bbb5-38568f978019"
        ]
      }
    ]
  },
  "outbound": {
    "classifiers": {
      "response": [
        "TODO - add marks based on status code, headers, network error and retriable, etc"
      ]
    },
    "global_limits": [
      {
        "id": "9d6c3542-8d4e-48e4-a205-6f15488c1fc1",
        "type": "RATE",
        "limit": 42,
        "time": {
          "value": 100,
          "unit": "MILLISECOND"
        },
        "if": [
          {
            "entity": "REQUEST",
            "mark": "ALL"
          }
        ],
        "add": [
          {
            "on": "OVERLOAD",
            "mark": {
              "entity": "REQUEST",
              "value": "OVERLOAD-9d6c3542-8d4e-48e4-a205-6f15488c1fc1"
            }
          }
        ]
      },
      {
        "id": "9ccb86a77-d318-4605-a4e4-52df1c9ba285",
        "type": "MAX_ACTIVE",
        "limit": 42,
        "if": [
          {
            "entity": "CONNECTION",
            "mark": "ALL"
          }
        ],
        "add": [
          {
            "on": "OVERLOAD",
            "mark": {
              "entity": "CONNECTION",
              "value": "OVERLOAD-9ccb86a77-d318-4605-a4e4-52df1c9ba285"
            }
          }
        ]
      }
    ],
    "clusters": [
      {
        "id": "f6033542-400c-48f7-9d9f-d86d470aad08",
        "type": "LEAF",
        "transport": {
          "type": "TLS",
          "context_index": "0d50e7dd-2e76-4d3e-b401-2826265893a8",
          "idle_timeout_millis": 30000,
          "retries": 3
        },
        "COMMENTS": [
          "Load balancing round robins across all endpoints until it finds one under limit or loops",
          "If no limits, then this is just round robin"
        ],
        "endpoints": [
          {
            "COMMENTS": [
              "valid types: IP4, IP6, CIDR4, CIDR6, FQDN, FQDN_RANGE, IP4_RANGE, IP6_RANGE",
              "FQDNs use DNS cache which honors TTLs"
            ],
            "type": "CIDR4",
            "values": [
              "127.0.0.1/32:8443"
            ]
          }
        ],
        "endpoint_limits": [
          {
            "type": "RATE",
            "limit": 42,
            "time": {
              "value": 100,
              "unit": "MILLISECOND"
            },
            "if": [
              {
                "entity": "REQUEST",
                "mark": "ALL"
              }
            ],
            "add": [
              {
                "on": "OVERLOAD",
                "mark": {
                  "entity": "REQUEST",
                  "value": "OVERLOAD-f6033542-400c-48f7-9d9f-d86d470aad08"
                }
              }
            ],
            "TODO": "Show how failover policies can be implemented based on rerouting on overload_mark"
          },
          {
            "type": "MAX_ACTIVE",
            "limit": 42,
            "if": [
              {
                "entity": "CONNECTION",
                "mark": "ALL"
              }
            ],
            "add": [
              {
                "on": "OVERLOAD",
                "mark": {
                  "entity": "CONNECTION",
                  "value": "OVERLOAD-f6033542-400c-48f7-9d9f-d86d470aad08"
                }
              }
            ]
          }
        ]
      },
      {
        "id": "ab671766-cb0d-4c5e-aa4a-815fcdb61877",
        "type": "COMPOSITE",
        "COMMENTS": [
          "Load balancing round robins across clusters by normalized weight until it finds one under limit or loops",
          "If no limits, then just weighted round robin across clusters, round robin within clusters"
        ],
        "clusters": [
          {
            "weight": 1,
            "cluster": "f6033542-400c-48f7-9d9f-d86d470aad08"
          }
        ]
      }
    ],
    "filters": [
      "TODO outbound request and response transforms",
      "Show OVERLOAD failover and retry on error",
      "TODO log and increment things based on various marks"
    ]
  },
  "inbound": {
    "classifiers": {
      "connection": [
        {
          "COMMENT": "turn this into a generic classifier - the listener post accept actions can use accept/deny default semantics",
          "id": "ff1679d4-558e-49ef-bcb9-aaf358a30430",
          "type": "firewall",
          "default": "DENY",
          "acls": [
            {
              "type": "PEER_ADDRESS",
              "patterns": [
                {
                  "type": "CIDRv4",
                  "values": [
                    "127.0.0.1/32"
                  ]
                },
                {
                  "type": "ISO 3166-2",
                  "value": "US"
                }
              ],
              "marks": [
                {
                  "entities": [
                    "connection"
                  ],
                  "values": [
                    "ALLOW"
                  ]
                }
              ]
            }
          ],
          "options": {
          }
        },
        {
          "id": "aa58d577-e41d-49ca-aec3-645a46adf89f",
          "type": "dos",
          "options": {
          }
        },
        "TODO set labels against source address, dest address, original dest address, SNI, client certificates",
        "TODO use things like CIDR ranges to classify clients?  Including default ALLOW/DENY?  Also geoIP?",
        "TODO - label based on port id, source CIDR/range on port, geoIP on port + name tag when limit is exceeded"
      ],
      "request": [
        "TODO set labels against paths, methods, headers",
        "TDOO add consistent hashes of headers + % selection to support canarying - % selection should support multiple buckets with residual going to a default",
        "TODO use things like CIDR ranges to classify clients?  Including default ALLOW/DENY?  Also geoIP?",
        "TODO - WAF use cases - mark suspicious patterns - apply WAF to stuff then specify label to apply if suspicious",
        "TODO - apply these to labels..., rewrite headers, etc.  Can code be inlined??",
        "TODO show application of sanitizers or rejection based on WAF marks",
        "TODO -compression?"
      ],
      "response": [
        "TODO things like incrementing metrics, alerting, error logging, adding field to access logs (access log format which logs the value or presecne of a tag?, and tracing if tags are matched"
      ]
    },
    "limits": [
      "TODO put inbound rate limits here - apply them in ports?  What about geo ip and ranges?",
      "Copy from token bucket terminology and semantics"
    ],
    "filters": [
      "distinguish between request and response filters",
      "different filter types - transformers, routers, delayers, redirectors, etc",
      "ROUTERS match a bunch of request and connection tags and either close connection, send response (including redirect), or forward to outbound/load_balancer",
      "ROUTERS may also apply transformations",
      "Could turn into filter chains",
      "COMMENT - show default deny firewall - if allow proceed, else close.  and reverse",
      "maybe filters can include actions to forward to other filters? - supports a DAG - order in list must be preserved",
      "TODO - close requests based on labels, or set socket options or idle timeout options",
      "TODO - attach limits to:  all traffic on port, source CIDR/range on port, geoIP on port + name tag when limit is exceeded",
      "TODO make this an inbound section?  Apply inbound rate limits for anti-DoS?",
      "TODO somehow express direct L4 forwarding here",
      "TODO - show routing based on overload marks",
      "Generic marking facility?  Have routes etc mark things up.  Need to show that routing is not final but rather just a mark and more processing is requred",
      "TODO - apply all routing rules that apply to all tags - precedence is tag FIFO (order that tags were applied to the request/connection)",
      "TODO - show inbound thorttling etc based on tag - add delay, reject with error response, reject and close connection",
      "TODO show failover due to overlimit - implicit: internally everscale will rerun selectors on OVERLOAD label - HOW DOES EVERSCALE KNOW AN OVERLOAD LABEL HAS BEEN ADDED??? - labels must have key, value, and meta data.  meta shows that the label is an overload label.  to decide whether to reroute request = 1 routing must have said OVERLOAD + request must have 1+ overload labels",
      "SHOULD A MORE GENERIC = REPROCESS or BACKUP TO STATE FOO BE EXPOSED???",
      "response transformations (header rewrite - also turning an outbound 2xx response to an inbound 5xx response",
      "telemetry TODO log and increment things based on various marks",
      {
        "id": "53da76cc-53e4-4abc-a06a-77d212bdcc71"
      }
    ],
    "ports": [
      {
        "id": "c542e5a9-4812-4d3d-a09a-6f7e2428a08e",
        "addresses": [
          "0.0.0.0:8443"
        ],
        "type": "TLS",
        "options": {
          "context_index": "81607fb3-7453-4372-995a-5e1f1317fd23",
          "listen_backlog": 123
        },
        "filter_head": "53da76cc-53e4-4abc-a06a-77d212bdcc71"
      }
    ]
  }
}
